use crate::Config;
use crate::FileOptions;
use std::path;
use std::error::Error;
use std::io::Write;

#[derive(Debug)]
pub struct Convert {
    config: Config,
    file_options: FileOptions,
}

impl Convert {
    pub fn new(config: Config, file_options: FileOptions) -> Convert {
        Convert { config, file_options }
    }

    pub fn from_args() -> Convert {
        let (config, file_options) = Config::from_args();
        Convert::new(config, file_options)
    }

    fn open_input(&self) -> Result<String, std::io::Error> {
        std::fs::read_to_string(&self.file_options.input)
    }

    fn open_output(&self) -> Result<std::fs::File, std::io::Error> {
        std::fs::File::create(&self.output_file_name()) // note this will overwrite
    }

    fn output_file_name(&self) -> String {
        self.file_options.output.clone().unwrap_or_else(|| {
            if self.file_options.output.is_some() {
                return self.file_options.input.clone();
            }
            let mut output = self.file_options.input.clone();
            // output.push_str(".out");
            // output
            // change extension to .v if there is extension
            let ext = path::Path::new(&output).extension().unwrap_or_default();
            if ext.is_empty() {
                output.push_str(".v");
            } else {
                output = output.replace(ext.to_str().unwrap(), "v");
            }
            output
        })
    }

    pub fn convert(&self) -> Result<(), Box<dyn Error>> {
        self.open_input()?;
        // open output
        let mut out_f = self.open_output()?;
        out_f.write_all(b"// Generated by PYTV")?;
        Ok(())
    }
}
